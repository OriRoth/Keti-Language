(defun contains (lst d)
	(cond
		((nil lst) ())
		((= (car lst) d) t)
		(t (contains (cdr lst) d))
	)
)

(defun remove (lst d)
	(cond
		((nil lst) ())
		((= (car lst) d) (remove (cdr lst) d))
		(t (cons (car lst) (remove (cdr lst) d)))
	)
)

(defun merge (l1 l2)
	(cond
		((nil l1) l2)
		(t (cons (car l1) (merge (cdr l1) l2)))
	)
)

(defun reverse (lst)
	(cond
		((nil lst) lst)
		(t (merge (reverse (cdr lst)) (list (car lst))))
	)
)

(defun evaluate_list (lst ev_func)
	(cond
		((nil lst) ())
		((nil (cdr lst)) (ev_func (car lst)))
		(t (+ (ev_func (car lst)) (evaluate_list (cdr lst) ev_func)))
	)
)

(defun quantity (d) 1)
(defun get_core (d) (core d))

(defun vertex (data n)
	(assign edges ()
	(assign name n
	(assign connect (defun _temp (v1 v2)
			(cond
				((contains (edges v1) v2) v1)
				(t (assign edges (cons v2 (edges v1)) v1))
			)
		)
	(assign scan (defun _temp (vlst front_insert)
			(cond
				((nil vlst) _route)
				((contains _route (car vlst)) ((invoke (car vlst) scan) (cdr vlst) front_insert))
				(t (value 	(setq _route (cons (car vlst) _route))
							(cond
								(front_insert (value
									((invoke (car vlst) scan) (edges (car vlst)) front_insert)
									((invoke (car vlst) scan) (cdr vlst) front_insert))
								)
								(t (value
									((invoke (car vlst) scan) (cdr vlst) front_insert)
									((invoke (car vlst) scan) (edges (car vlst)) front_insert))
								)
							)
							))
			)
		)
	(assign dfs (defun _temp (v)
			(value	(setq _route ())
					((invoke v scan) (list v) t)
					(reverse _route)
			)
		)
	(assign bfs (defun _temp (v)
			(value	(setq _route ())
					((invoke v scan) (list v) ())
					(reverse _route)
			)
		)
	(assign net_size (defun _temp (v)
			(evaluate_list (dfs v) quantity)
		)
	(assign net_value (defun _temp (v)
			(evaluate_list (dfs v) get_core)
		)
		data))))))))
)

(defun pointer (s c)
	(assign state s
	(assign char c
	(assign = (defun _temp (p1 p2)
			(and (= (state p1) (state p2)) (= (char p1) (char p2)))
		)
		())))
)

(defun arrows (conns)
	(assign connections conns
	(assign add_connection (defun _temp (ar p)
			(cond
				((contains (connections ar) p) ar)
				(t (assign connections (cons p (connections ar)) ar))
			)
		)
	(assign remove_connection (defun _temp (ar p)
			(assign connections (remove (connections ar) p) ar)
		)
	(assign next (defun _temp (ar c)
			(next_helper ar (connections ar) c)
		)
	(assign next_helper (defun _temp (ar clst c)
			(cond
				((nil clst) (error "machine stuck"))
				((= (char (car clst)) c) (state (car clst)))
				(t (next_helper ar (cdr clst) c))
			)
		)
	(assign car (defun _sol (ar)
			(state (car (connections ar)))
		)
	(assign cdr (defun _sol (ar)
			(arrows (cdr (connections ar)))
		)
	(assign nil (defun _sol (ar)
			(nil (connections ar))
		)
		()))))))))
)

(defun state (is_a n)
	(assign is_accepting is_a
	(assign links (arrows ())
	(assign edges (defun _temp (s)
			(links s)
		)
	(assign connect (defun _temp (s1 s2 c)
			(add_connection (links s1) (pointer s2 c))
		)
	(assign disconnect (defun _temp (s1 s2 c)
			(remove_connection (links s1) (pointer s2 c))
		)
	(assign in_language (defun _temp (s wlst)
			(cond
				((nil wlst) (is_accepting s))
				(t (in_language (next (links s) (car wlst)) (cdr wlst)))
			)
		)
		(vertex () n)))))))
)

(setq q0 (state () "q0"))
(setq q1 (state () "q1"))
(setq q2 (state () "q2"))
(setq q3 (state t "q3"))
(connect q0 q0 "0")
(connect q0 q1 "1")
(connect q1 q2 "0")
(connect q1 q1 "1")
(connect q2 q0 "0")
(connect q2 q3 "1")
(connect q3 q3 "0")
(connect q3 q3 "1")
(net_size q0)
(in_language q0 (list "1" "0" "0" "1" "0" "1" "0" "1" "1"))
(in_language q0 (list "1" "0" "0" "1" "0" "0" "0" "1" "1"))
(assign is_accepting t q0)
(assign is_accepting t q1)
(assign is_accepting t q2)
(assign is_accepting () q3)
(in_language q0 (list "1" "0" "0" "1" "0" "1" "0" "1" "1"))
(in_language q0 (list "1" "0" "0" "1" "0" "0" "0" "1" "1"))
