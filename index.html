<!DOCTYPE html>
<meta charset="utf-8" />
<html lang="he">
  <head>
    <meta charset="UTF-8">
    <title>Keti Programming Language by Ori Roth</title>
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <link rel="stylesheet" type="text/css" href="stylesheets/normalize.css" media="screen">
    <link href='https://fonts.googleapis.com/css?family=Open+Sans:400,700' rel='stylesheet' type='text/css'>
    <link rel="stylesheet" type="text/css" href="stylesheets/stylesheet.css" media="screen">
    <link rel="stylesheet" type="text/css" href="stylesheets/github-light.css" media="screen">
  </head>
  <body>
    <section class="page-header">
      <h1 class="project-name">Keti Programming Language</h1>
      <h2 class="project-tagline">by Ori Roth</h2>
      <a href="https://github.com/OriRoth/Keti-Programming-Language" class="btn" target="_blank">View on GitHub</a>
      <a href="https://github.com/OriRoth/Keti-Programming-Language/zipball/master" class="btn">Download .zip</a>
      <a href="https://github.com/OriRoth/Keti-Programming-Language/tarball/master" class="btn">Download .tar.gz</a>
    </section>

    <section class="main-content">

<h3>Background:</h3>
<p>This is a minimalistic virtualization of a classic <a href="ftp://www.cs.utexas.edu/pub/AI-Lab/tech-reports/UT-AI-TR-85-6.pdf">Lisp</a> Machine, written in C. This implementation is very dynamic, easy to learn and fun! There is no use of pointers/allocations in the code (C accessories), only logic - the system is independent, and deals its memory by itself (including memory sweep). I am a Software Engineering student at the Technion, Israel, and this project was done at the summer of 2015.</p>

<h3>Micro Lisp Style:</h3>
<p>Language values are: positive integers, strings, true, nil and cons (tuple of two other base values).</p>
<p>Supported native functions are:</p>
<table style="width:60%;text-align:center" align="center">
	<tr>
		<th>native function</th>
		<th>number of arguments</th>
		<th>what it does</th>
	</tr>
	<tr>
		<td>quote</td>
		<td>1</td>
		<td>Return the argument as it is, without interpretation. Could be used in many ways, such as making lists [(quote (1 2 3)) => (1 (2 (3 nil)))] or making symbols [(quote x) => (<symbol identifier> ("x" nil))].</td>
	</tr>
	<tr>
		<td>define</td>
		<td>2</td>
		<td>Parameters are a symbol and a value. Makes the symbol a new variable, with the received value (see below).</td>
	</tr>
	<tr>
		<td>lambda</td>
		<td>2</td>
		<td>Parameters are a list of parameters and a value. Return a new function, with the received parameters list and value (see below).</td>
	</tr>
	<tr>
		<td>if</td>
		<td>3</td>
		<td>Resolve the first argument. If it is true, return the second argument, else the third (if-else structure).</td>
	</tr>
	<tr>
		<td>atom</td>
		<td>1</td>
		<td>Returns true if the argument is not cons, else false.</td>
	</tr>
	<tr>
		<td>cons</td>
		<td>2</td>
		<td>Creates a new cons, of the two received values.</td>
	</tr>
	<tr>
		<td>car , cdr</td>
		<td>1</td>
		<td>Receives a cons, and return its car/cdr.</td>
	</tr>
	<tr>
		<td>+ , - , * , / , = , > , < </td>
		<td>2</td>
		<td>Exactly what you think it does.</td>
	</tr>
	<tr>
		<td>nil</td>
		<td>1</td>
		<td>Receives a value. Return true if it is nil, else false.</td>
	</tr>
</table>
<p>Most expressions are in the form of <a href="https://en.wikipedia.org/wiki/Polish_notation" target="_blank">Prefix Notation</a> (&lt;function_name&gt; [&lt;arguments, seperated by spaces&gt;]) - in parentheses, and the function comes before the arguments (if any) <a href="http://webcourse.cs.technion.ac.il/234319/Spring2015/ho/WCFiles/_article-3-+-values-and-types.pdf" target="_blank">See more</a>. Moreover, there are special structures which require specific identification: lambda functions (functions created by you) and symbols (system structure, used to connect a name to a value).</p>
<p><div align="center"><img src="http://s30.postimg.org/pcumb4zsx/img1.png" alt="lambda functions and symbols structure"></div></p>
<p>Some simple examples:</p>
<table style="width:50%;text-align:center" align="center">
	<tr>
		<th>input</th>
		<th>result</th>
	</tr>
	<tr>
		<td>(+ 1 1)</td>
		<td>2</td>
	</tr>
	<tr>
		<td>(> 5 2)</td>
		<td>t</td>
	</tr>
	<tr>
		<td>(car (cons "car" "cdr"))</td>
		<td>"car"</td>
	</tr>
	<tr>
		<td>(lambda (x) (* 2 x))</td>
		<td>{function that receives a number, return the number multiplied by two}</td>
	</tr>
	<tr>
		<td>(define x 3)</td>
		<td>3 {and now x:=3}</td>
	</tr>
</table>

<h3>What is in the files:</h3>
<p>* mainloop: contains the main function, which has the main game loop that waits for input, translate and process it and show the result (or error) on screen.</p>
<p>* system: contains the main translation functions: resolve_expr (which receive a value and resolve it recursively), and lookup (which receive a symbol and return its value).</p>
<p>* memory: deals with memory management. Supports allocation of cons, and the mark-sweep algorithm.</p>
<p>* bitarray: supplies us with bit array, makros supporters.</p>
<p>* native: contains the implementation of the native functions.</p>
<p>* error: contains the errors logic.</p>

<h3>Structure:</h3>
<p>The language implementation is built from three main parts: memory management (memory.c, memory.h), expressions execution (system.c, system.h) and the interpreter (mainloop.c). We will now cover the techniques used in each level of the language.</p>

<b>Memory Management:</b>
<p>The memory system contains two pools (large arrays of available space): pool of cons (32 bits) - cons_pool, and pool of characters - strings_pool. Alongside the pools we hold a free addresses stack for the cons pool (every time we allocate a cons, we pop an address from the stack and returns it), and a filler for the characters pool (integer pointing the first free cell- during allocation we forward the filler by number of cells equals the length of the allocated string). Shallow copy of strings is supported- instead of pointing the string in the pool, string values (in cons pool) point string handlers (special structure on the cons pool, takes whole cons 32 bits), which are special cons that contains the actual address of the string. Instead of allocating a new string when copying one, we just redirect it to the same handler. Placing the handlers on the cons pool is not mandatory, but it saves a lot of space saved when cancelling the handlers pool.</p>
<p>When one of the pools is being filled, it is very possible that there are stale allocations we have done sometime in the past, which are no longer required. So instead of crashing the system, we preform <a href="https://en.wikipedia.org/wiki/Tracing_garbage_collection#Basic_algorithm" target="_blank">Garbage Collection</a>. Now we will describe the specific algorithm used in our memory system: First we define a root set- group of cons addresses that are valid and required (such as the current environment, see below). We mark every valid address- notice that the marking process is recursive, marking addresses from the root set and addresses pointed by them. Then we scan the cons pool, pushing free (or used but invalid) addresses to the free addresses stack. Additionally, if an address is mark and its car is handler identifier (special value used only for this purpose), then we push the address to another stack- handlers_sort_buffer. This buffer allows us to clean the strings pool- we sort the handler addresses by string address (at the strings pool), and then moving the strings one by one to the start of the pool (so we can move the strings filler to the left, means more free characters cells to its right). In conclusion, the first part of the algorithm is classic mark and sweep, but dealing with the strings required us using something called <a href="https://en.wikipedia.org/wiki/Fragmentation_%28computing%29" target="_blank">fragmentation</a> (the Hebrew version is very nice fyi).</p>

<b>System Management and Translation:</b>
<p>The system uses a special cons structure called A-List. This is a simple cons list, represent the current environment nesting (the head of the list is the current environment). Each environment contains translation list- list of symbols (names and their values). The initial symbols stands for the native function. When we use define, we connect a name with a value- there are two options:</p>
<p>a) The symbol is not defined: the symbol is inserted to the current environment.</p>
<p>b) The symbol is already defined, in some environment: the symbol's value is replaced (it does not change place).</p>
<p>When we use a user function, a new environment is created (its next environment is the previous one), while the arguments sent to the function are being computed and inserted to it (as symbols- they are being linked to the function's parameters in order to create the symbols). Next the function value is computed in the new environment, and finally we destroy the environment (by redirecting the current environment index to the next environment).</p>
<p><div align="center"><img src="http://s2.postimg.org/kfuz68owp/img2.png" alt="system structure"></div></p>
<p><div align="center">The system structure- a list (environment nodes) of lists (symbols nodes). This specific state of the system can occur after calling a user function, which uses x as a parameter, with 7 as the argument [for instance, (factorial 7) when factorial is defined by (define factorial (lambda (x) (...)))].</div></p>

<h3>More about programming languages</h3>
<p>As you may have seen, many aspects of programming languages can be observed in this Micro Lisp implementation:</p>
<p><a href="https://www.youtube.com/watch?v=_C5AHaS1mOA">Compilation by Interpreter</a> - a program is computed one row at a time. In this implementation, the interpreter turns a code line to a translatable object (sitting in the cons pool), ready to be evaluated.</p>
<p><a href="https://en.wikipedia.org/wiki/Type_system#DYNAMIC">Dynamic Typing</a> - language values has rtti (run time type information), indicating their type. No type checks occur, type mismatch means run time failure.</p>
<p><a href="https://en.wikipedia.org/wiki/Strong_and_weak_typing#Definitions_of_.22strong.22_or_.22weak.22">Strong Typing</a> - no implicit cast (actually no casts at all...).</p>
<p><a href="https://en.wikipedia.org/wiki/Union_type">Union Type</a> - a cons is compound of car and cdr: each of them can be a pointer to another cons, or an atomic value (<a href="http://webcourse.cs.technion.ac.il/234319/Spring2015/ho/WCFiles/_article-3-+-values-and-types.pdf" target="_blank">See more</a>).</p>
<p>Garbage Collection - explained quite well before (under Memory Management).</p>

<h3>Examples</h3>
<p><a href="examples/simple_example.kpl">First Steps in Lisp</a> - you can experience the various operations, available in this implementation. Pay attention to the prefix notation, and to the way we define variables (remember functions are also values! "functions" as you know them are simply variables containing function values).</p>
<p><a href="examples/writing_functions.kpl">Functions</a> - pay attention to the way we use conditioning (if native). We can make lists using "quote": (1 2 3) this will not run properly, as the system will try to use "1" as a function and fail. (quote (1 2 3)) will work, and will generate the list (1 (2 (3 ()))) ("()" is nil value, also """"). The interpreter translate the phrase "(1 2 3)" to this list, and quote returns it without evaluation.</p>
<p><a href="examples/capabilities.kpl">Advanced Language Capabilities</a> - remember the functions and symbols structure (see above). We can extract the lambda and symbol identifiers, using car operation on function and symbol values ("(quote x)" returns symbol, because quote does not evaluate its parameter). "eval" function (from the program) receives a symbol and return its evaluation: we use manipulations to activate the lookup procedure. "design" gets a list of symbols and a value, and translate recursively each symbol that appears in the parameter, unless its on the list. Pay attention how we use design in order to build "constant" - a function that gets a function of two parameters and a value, and returns a function of one parameter that compute the received function with the received value and its parameter. For example, (constant + 8) returns a function that receives a parameter, and add 8 to it. This example shows the great power of this language - although it is a minimized implementation, you are not limited at all and can make very sophisticated procedures (I have made a functions that creates polynomials. You can try by yourselves!).</p>

<h3>Exercise</h3>
<p>Self Practice:</p>
<p><b>a)</b> What are the similarities and differences between these two problems?</p>
<p>- Write a function that receives a list of numbers, and multiply each number by 2 (called double).</p>
<p><p>- Write a function that receives a list of numbers, and returns its members multiplication (called multilist).</p></p>
<p>Many languages (such as Python) supports "map" and "reduce" functions. Map receives a function and a list, and applies the function to every item of the list (and returns a list of the results). Reduce also receives a function (of two parameters) and a list, and reduce the list into one value (you may search for examples on the net).</p>
<p><b>b)</b> Implement map and reduce functions <a href="examples/exercise.kpl">in this file</a>.</p>
<p><b>c)</b> In the same file, implement double and multilist functions (described above), using map and reduce you have wrote. You can add other functions to the program, if you want.</p>

<h3>Challenges</h3>
<p><a href="examples/equals.kpl">Equals</a> - the "=" native compares cons by address. Override it with an implement that compares cons recursively (dont forget to save the native "=" in some variable! we still want to use it).</p>
<p>Want more? Contact me via email.</p>

<h3>Object Oriented?</h3>
<p>The idea behind Keti language was to create an object oriented extension of Micro Lisp, and objects were actualy implemented in the previous versions (not in the current, I'm afraid). It could be done by adding two natives:</p>
<p>- assign: receives a symbol, a value and some item. If the item is not an object, it turns it into one while adding the value as a field with the received symbol. Otherwise adds the field to the object.</p>
<p>- supps: receive a symbol and an item. Returns true if the item (which can be cons/atom/object) supports a function with that symbol. For objects, it may happen when the symbol one of it fields, or otherwise when the symbol indicates a global function or a native.</p>
<p>When calling a function, we should check if the first argument is an object. If so, we check if the function's symbol appears in its fields list- if it does, we call it instead.</p>
<p>How we build objects? Objects should be identified using an identifier similar to those of lambda expressions and symbols. It should contain a list of its fields, while the original value (we turn into object) rests under "core" field (and it should be accessed when using some natives).</p>
<p>Use example:</p>
<p>(define x (assign r 5 6))					; Now x is an object, that contains 6 under "core" field, and 5 under "r" field.</p>
<p>(r x)							; => 5.</p>
<p>(assign + (lambda (x y) (+ (+ (r x) (core x)) y)) x)		; we overrided + operation for x.</p>
<p>(+ x 2)							; => 13.</p>
<p>(+ 2 x)							; => 8.</p>

<a href="google4f28465c7feae320.html">For Google</a>
<!--done for now...-->

      <footer class="site-footer">
        <span class="site-footer-owner"><a href="https://github.com/OriRoth/Keti-Programming-Language">Keti-programming-language</a> is maintained by <a href="https://github.com/OriRoth">OriRoth</a>.</span>

        <span class="site-footer-credits">This page was generated by <a href="https://pages.github.com">GitHub Pages</a> using the <a href="https://github.com/jasonlong/cayman-theme">Cayman theme</a> by <a href="https://twitter.com/jasonlong">Jason Long</a>.</span>
      </footer>

    </section>

  
  </body>
</html>
