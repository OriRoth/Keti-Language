<!DOCTYPE html>
<html lang="en-us">
  <head>
    <meta charset="UTF-8">
    <title>Keti Programming Language by Ori Roth</title>
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <link rel="stylesheet" type="text/css" href="stylesheets/normalize.css" media="screen">
    <link href='https://fonts.googleapis.com/css?family=Open+Sans:400,700' rel='stylesheet' type='text/css'>
    <link rel="stylesheet" type="text/css" href="stylesheets/stylesheet.css" media="screen">
    <link rel="stylesheet" type="text/css" href="stylesheets/github-light.css" media="screen">
  </head>
  <body>
    <section class="page-header">
      <h1 class="project-name">Keti Programming Language</h1>
      <h2 class="project-tagline">by Ori Roth</h2>
      <a href="https://github.com/OriRoth/Keti-Programming-Language" class="btn" target="_blank">View on GitHub</a>
      <a href="https://github.com/OriRoth/Keti-Programming-Language/zipball/master" class="btn">Download .zip</a>
      <a href="https://github.com/OriRoth/Keti-Programming-Language/tarball/master" class="btn">Download .tar.gz</a>
    </section>

    <section class="main-content">

<h3>Background:</h3>
<p>This object oriented version of Micro Lisp is very dynamic, easy to learn and fun. I am a Software Engineering student at the Technion, Israel. This project was done at the summer of 2015.</p>

<h3>Micro Lisp Style:</h3>
<p>Both languages share the same base values, which are: positive integers, strings, true, nil and cons (tuple of two other base values).</p><p>Most expressions are in the form of (&lt;function_name&gt; [&lt;arguments, seperated by &#39; &#39;&gt;]) - in parentheses, and the function comes before the arguments (if any). <a href="http://webcourse.cs.technion.ac.il/234319/Spring2015/ho/WCFiles/_article-3-+-values-and-types.pdf" target="_blank">See more</a></p>

<h3>What is in the files:</h3>
<p>* mainloop: contains the main function, which has the main game loop that waits for input, translate and process it and show the result on screen (or error).</p>
<p>* system: has two main, important parts: the function responsible on the recursive execution of expression, and the implementation of the base functions.</p>
<p>* memmanage: deals with memory management. Supports allocation of cons, and the mark-sweep algorithm.</p>
<p>* bitarray: supplies us with bit array, makros supporters.</p>

<h3>Structure:</h3>
<p>The language implementation is built from three main parts: memory management (memmanage), expressions execution (system) and the interpreter. We will now cover the techniques used in each level of the language.</p>

<b>Memory Management:</b>
<p>All the systems components are represented as cons (see below), thus we support only cons and strings allocation and garbage collection. The cons and string handlers pools are 2^14  in size. Each cons is parted: left type (2bits), left data(14bits), right type (2bits) and right data(14bits). The supported types are integer, string, nil and cons. The string data is the address of a string handler in the string handlers pool, that contains the address of the actual string in the characters pool.</p>
<p>The cons and string handler pools are maintained by bit mark arrays. The cons pool mark array is designed as a binari tree, when a vertex is marked iff all its subtree is marked thus occupied. So one can search for a free cons cell in the pool in log(pool size). When allocating a string, a string handler is allocated as well. It marks a range of char cells in the strings pool as his own. Both the string handlers ans strings pool are maintained by "fillers", pointers that preserve an invariant: everything left of them is allocated (used or not), and everything on the right is free.</p>
<p><i>Mark n Sweep</i>- Starting from the base group (see below), we re-mark the allocated, in use cons. Then we do the same with the string handlers, moving them to the start of the pool (alongside the filler), sort them by string pool address and move the strings to the start of the pool. That way we a) zero marks of unused cons allocations and b) moves the fillers to the left (means more free space to their right).</p>
<img src="pictures/picture1.bmp" alt="Memory hierarchy structure" style="width:300px;height:300px;">

<a href="google4f28465c7feae320.html">For Google</a>

      <footer class="site-footer">
        <span class="site-footer-owner"><a href="https://github.com/OriRoth/Keti-Programming-Language">Keti-programming-language</a> is maintained by <a href="https://github.com/OriRoth">OriRoth</a>.</span>

        <span class="site-footer-credits">This page was generated by <a href="https://pages.github.com">GitHub Pages</a> using the <a href="https://github.com/jasonlong/cayman-theme">Cayman theme</a> by <a href="https://twitter.com/jasonlong">Jason Long</a>.</span>
      </footer>

    </section>

  
  </body>
</html>
